// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --version 3
// RUN: %clang_cc1 -triple x86_64-unknown-unknown -O1 -disable-llvm-optzns -ffull-restrict %s -emit-llvm -o - | FileCheck %s

int r;
void ex1(int *);

// CHECK-LABEL: define dso_local void @test_FOO_local(
// CHECK-SAME: ptr noundef [[PA:%.*]], ptr noundef [[PB:%.*]], ptr noundef [[PC:%.*]]) #[[ATTR0:[0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[PA_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[PB_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[PC_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[TMP:%.*]] = alloca [3 x ptr], align 16
// CHECK-NEXT:    store ptr [[PA]], ptr [[PA_ADDR]], align 8, !tbaa [[TBAA2:![0-9]+]], !noalias !6
// CHECK-NEXT:    store ptr [[PB]], ptr [[PB_ADDR]], align 8, !tbaa [[TBAA2]], !noalias !6
// CHECK-NEXT:    store ptr [[PC]], ptr [[PC_ADDR]], align 8, !tbaa [[TBAA2]], !noalias !6
// CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 24, ptr [[TMP]]) #[[ATTR4:[0-9]+]], !noalias !6
// CHECK-NEXT:    [[TMP0:%.*]] = call ptr @llvm.noalias.decl.p0.p0.i64(ptr [[TMP]], i64 0, metadata [[META6:![0-9]+]]), !noalias !6
// CHECK-NEXT:    [[ARRAYINIT_BEGIN:%.*]] = getelementptr inbounds [3 x ptr], ptr [[TMP]], i64 0, i64 0
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[PA_ADDR]], align 8, !tbaa [[TBAA2]], !noalias !6
// CHECK-NEXT:    store ptr [[TMP1]], ptr [[ARRAYINIT_BEGIN]], align 8, !tbaa [[TBAA2]], !noalias !6
// CHECK-NEXT:    [[ARRAYINIT_ELEMENT:%.*]] = getelementptr inbounds ptr, ptr [[ARRAYINIT_BEGIN]], i64 1
// CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[PB_ADDR]], align 8, !tbaa [[TBAA2]], !noalias !6
// CHECK-NEXT:    store ptr [[TMP2]], ptr [[ARRAYINIT_ELEMENT]], align 8, !tbaa [[TBAA2]], !noalias !6
// CHECK-NEXT:    [[ARRAYINIT_ELEMENT1:%.*]] = getelementptr inbounds ptr, ptr [[ARRAYINIT_ELEMENT]], i64 1
// CHECK-NEXT:    [[TMP3:%.*]] = load ptr, ptr [[PC_ADDR]], align 8, !tbaa [[TBAA2]], !noalias !6
// CHECK-NEXT:    store ptr [[TMP3]], ptr [[ARRAYINIT_ELEMENT1]], align 8, !tbaa [[TBAA2]], !noalias !6
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [3 x ptr], ptr [[TMP]], i64 0, i64 0
// CHECK-NEXT:    [[TMP4:%.*]] = load ptr, ptr [[ARRAYIDX]], align 16, !tbaa [[TBAA2]], !noalias !6
// CHECK-NEXT:    [[TMP5:%.*]] = call ptr @llvm.noalias.p0.p0.p0.i64(ptr [[TMP4]], ptr [[TMP0]], ptr [[ARRAYIDX]], i64 0, metadata [[META6]]), !tbaa [[TBAA2]], !noalias !6
// CHECK-NEXT:    store i32 42, ptr [[TMP5]], align 4, !tbaa [[TBAA9:![0-9]+]], !noalias !6
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [3 x ptr], ptr [[TMP]], i64 0, i64 1
// CHECK-NEXT:    [[TMP6:%.*]] = load ptr, ptr [[ARRAYIDX2]], align 8, !tbaa [[TBAA2]], !noalias !6
// CHECK-NEXT:    [[TMP7:%.*]] = call ptr @llvm.noalias.p0.p0.p0.i64(ptr [[TMP6]], ptr [[TMP0]], ptr [[ARRAYIDX2]], i64 0, metadata [[META6]]), !tbaa [[TBAA2]], !noalias !6
// CHECK-NEXT:    store i32 43, ptr [[TMP7]], align 4, !tbaa [[TBAA9]], !noalias !6
// CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 24, ptr [[TMP]]) #[[ATTR4]]
// CHECK-NEXT:    ret void
//
void test_FOO_local(int *pA, int *pB, int *pC) {
  int *restrict tmp[3] = {pA, pB, pC};
  *tmp[0] = 42;
  *tmp[1] = 43;
}


// CHECK-LABEL: define dso_local void @test_FOO_p(
// CHECK-SAME: ptr noalias noundef [[P:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[P_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[TMP0:%.*]] = call ptr @llvm.noalias.decl.p0.p0.i64(ptr [[P_ADDR]], i64 0, metadata [[META11:![0-9]+]]), !noalias !11
// CHECK-NEXT:    store ptr [[P]], ptr [[P_ADDR]], align 8, !tbaa [[TBAA2]], !noalias !11
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[P_ADDR]], align 8, !tbaa [[TBAA2]], !noalias !11
// CHECK-NEXT:    [[TMP2:%.*]] = call ptr @llvm.noalias.p0.p0.p0.i64(ptr [[TMP1]], ptr [[TMP0]], ptr [[P_ADDR]], i64 0, metadata [[META11]]), !tbaa [[TBAA2]], !noalias !11
// CHECK-NEXT:    store i32 42, ptr [[TMP2]], align 4, !tbaa [[TBAA9]], !noalias !11
// CHECK-NEXT:    ret void
//
void test_FOO_p(int *restrict p) {
  *p = 42;
}

// define void @test_FOO_p(i32* noalias %p) #0 {

// CHECK-LABEL: define dso_local void @test_FOO_pp(
// CHECK-SAME: ptr noundef [[P:%.*]]) #[[ATTR0]] !noalias !14 {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[P_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[P]], ptr [[P_ADDR]], align 8, !tbaa [[TBAA2]], !noalias !14
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P_ADDR]], align 8, !tbaa [[TBAA2]], !noalias !14
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds ptr, ptr [[TMP0]], i64 0
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[ARRAYIDX]], align 8, !tbaa [[TBAA2]], !noalias !14
// CHECK-NEXT:    [[TMP2:%.*]] = call ptr @llvm.noalias.p0.p0.p0.i64(ptr [[TMP1]], ptr null, ptr [[ARRAYIDX]], i64 0, metadata [[META14:![0-9]+]]), !tbaa [[TBAA2]], !noalias !14
// CHECK-NEXT:    store i32 42, ptr [[TMP2]], align 4, !tbaa [[TBAA9]], !noalias !14
// CHECK-NEXT:    ret void
//
void test_FOO_pp(int *restrict *p) {
  *p[0] = 42;
}

// define void @test_FOO_pp(i32** %p) #0 !noalias !14 {
