// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --version 3
// RUN: %clang_cc1 -triple x86_64-unknown-unknown -O1 -disable-llvm-optzns -ffull-restrict %s -emit-llvm -o - | FileCheck %s

int r;
void ex1(int *);

struct FOO {
  int *restrict rp0;
  int *restrict rp1;
  int *restrict rp2;
};

// CHECK-LABEL: define dso_local void @test_FOO_local(
// CHECK-SAME: ptr noundef [[PA:%.*]], ptr noundef [[PB:%.*]], ptr noundef [[PC:%.*]]) #[[ATTR0:[0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[PA_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[PB_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[PC_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[TMP:%.*]] = alloca [[STRUCT_FOO:%.*]], align 8
// CHECK-NEXT:    store ptr [[PA]], ptr [[PA_ADDR]], align 8, !tbaa [[TBAA2:![0-9]+]], !noalias !6
// CHECK-NEXT:    store ptr [[PB]], ptr [[PB_ADDR]], align 8, !tbaa [[TBAA2]], !noalias !6
// CHECK-NEXT:    store ptr [[PC]], ptr [[PC_ADDR]], align 8, !tbaa [[TBAA2]], !noalias !6
// CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 24, ptr [[TMP]]) #[[ATTR6:[0-9]+]], !noalias !6
// CHECK-NEXT:    [[TMP0:%.*]] = call ptr @llvm.noalias.decl.p0.p0.i64(ptr [[TMP]], i64 0, metadata [[META6:![0-9]+]]), !noalias !6
// CHECK-NEXT:    [[RP0:%.*]] = getelementptr inbounds [[STRUCT_FOO]], ptr [[TMP]], i32 0, i32 0
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[PA_ADDR]], align 8, !tbaa [[TBAA2]], !noalias !6
// CHECK-NEXT:    store ptr [[TMP1]], ptr [[RP0]], align 8, !tbaa [[TBAA9:![0-9]+]], !noalias !6
// CHECK-NEXT:    [[RP1:%.*]] = getelementptr inbounds [[STRUCT_FOO]], ptr [[TMP]], i32 0, i32 1
// CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[PB_ADDR]], align 8, !tbaa [[TBAA2]], !noalias !6
// CHECK-NEXT:    store ptr [[TMP2]], ptr [[RP1]], align 8, !tbaa [[TBAA11:![0-9]+]], !noalias !6
// CHECK-NEXT:    [[RP2:%.*]] = getelementptr inbounds [[STRUCT_FOO]], ptr [[TMP]], i32 0, i32 2
// CHECK-NEXT:    [[TMP3:%.*]] = load ptr, ptr [[PC_ADDR]], align 8, !tbaa [[TBAA2]], !noalias !6
// CHECK-NEXT:    store ptr [[TMP3]], ptr [[RP2]], align 8, !tbaa [[TBAA12:![0-9]+]], !noalias !6
// CHECK-NEXT:    [[RP01:%.*]] = getelementptr inbounds [[STRUCT_FOO]], ptr [[TMP]], i32 0, i32 0
// CHECK-NEXT:    [[TMP4:%.*]] = load ptr, ptr [[RP01]], align 8, !tbaa [[TBAA9]], !noalias !6
// CHECK-NEXT:    [[TMP5:%.*]] = call ptr @llvm.noalias.p0.p0.p0.i64(ptr [[TMP4]], ptr [[TMP0]], ptr [[RP01]], i64 0, metadata [[META6]]), !tbaa [[TBAA9]], !noalias !6
// CHECK-NEXT:    store i32 42, ptr [[TMP5]], align 4, !tbaa [[TBAA13:![0-9]+]], !noalias !6
// CHECK-NEXT:    [[RP12:%.*]] = getelementptr inbounds [[STRUCT_FOO]], ptr [[TMP]], i32 0, i32 1
// CHECK-NEXT:    [[TMP6:%.*]] = load ptr, ptr [[RP12]], align 8, !tbaa [[TBAA11]], !noalias !6
// CHECK-NEXT:    [[TMP7:%.*]] = call ptr @llvm.noalias.p0.p0.p0.i64(ptr [[TMP6]], ptr [[TMP0]], ptr [[RP12]], i64 0, metadata [[META6]]), !tbaa [[TBAA11]], !noalias !6
// CHECK-NEXT:    store i32 43, ptr [[TMP7]], align 4, !tbaa [[TBAA13]], !noalias !6
// CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 24, ptr [[TMP]]) #[[ATTR6]]
// CHECK-NEXT:    ret void
//
void test_FOO_local(int *pA, int *pB, int *pC) {
  struct FOO tmp = {pA, pB, pC};
  *tmp.rp0 = 42;
  *tmp.rp1 = 43;
}

// CHECK-LABEL: define dso_local void @test_FOO_arg_pointer(
// CHECK-SAME: ptr noundef [[P:%.*]]) #[[ATTR0]] !noalias !15 {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[P_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[P]], ptr [[P_ADDR]], align 8, !tbaa [[TBAA2]], !noalias !15
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P_ADDR]], align 8, !tbaa [[TBAA2]], !noalias !15
// CHECK-NEXT:    [[RP0:%.*]] = getelementptr inbounds [[STRUCT_FOO:%.*]], ptr [[TMP0]], i32 0, i32 0
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[RP0]], align 8, !tbaa [[TBAA9]], !noalias !15
// CHECK-NEXT:    [[TMP2:%.*]] = call ptr @llvm.noalias.p0.p0.p0.i64(ptr [[TMP1]], ptr null, ptr [[RP0]], i64 0, metadata [[META15:![0-9]+]]), !tbaa [[TBAA9]], !noalias !15
// CHECK-NEXT:    store i32 42, ptr [[TMP2]], align 4, !tbaa [[TBAA13]], !noalias !15
// CHECK-NEXT:    [[TMP3:%.*]] = load ptr, ptr [[P_ADDR]], align 8, !tbaa [[TBAA2]], !noalias !15
// CHECK-NEXT:    [[RP1:%.*]] = getelementptr inbounds [[STRUCT_FOO]], ptr [[TMP3]], i32 0, i32 1
// CHECK-NEXT:    [[TMP4:%.*]] = load ptr, ptr [[RP1]], align 8, !tbaa [[TBAA11]], !noalias !15
// CHECK-NEXT:    [[TMP5:%.*]] = call ptr @llvm.noalias.p0.p0.p0.i64(ptr [[TMP4]], ptr null, ptr [[RP1]], i64 0, metadata [[META15]]), !tbaa [[TBAA11]], !noalias !15
// CHECK-NEXT:    store i32 43, ptr [[TMP5]], align 4, !tbaa [[TBAA13]], !noalias !15
// CHECK-NEXT:    ret void
//
void test_FOO_arg_pointer(struct FOO *p) {
  *p->rp0 = 42;
  *p->rp1 = 43;
}

// define void @test_FOO_arg_pointer(%struct.FOO* %p) #0 !noalias !15 {

// CHECK-LABEL: define dso_local void @test_FOO_arg_value(
// CHECK-SAME: ptr noundef byval([[STRUCT_FOO:%.*]]) align 8 [[P:%.*]]) #[[ATTR0]] !noalias !18 {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[RP0:%.*]] = getelementptr inbounds [[STRUCT_FOO]], ptr [[P]], i32 0, i32 0
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[RP0]], align 8, !tbaa [[TBAA9]], !noalias !18
// CHECK-NEXT:    [[TMP1:%.*]] = call ptr @llvm.noalias.p0.p0.p0.i64(ptr [[TMP0]], ptr null, ptr [[RP0]], i64 0, metadata [[META18:![0-9]+]]), !tbaa [[TBAA9]], !noalias !18
// CHECK-NEXT:    store i32 42, ptr [[TMP1]], align 4, !tbaa [[TBAA13]], !noalias !18
// CHECK-NEXT:    [[RP1:%.*]] = getelementptr inbounds [[STRUCT_FOO]], ptr [[P]], i32 0, i32 1
// CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[RP1]], align 8, !tbaa [[TBAA11]], !noalias !18
// CHECK-NEXT:    [[TMP3:%.*]] = call ptr @llvm.noalias.p0.p0.p0.i64(ptr [[TMP2]], ptr null, ptr [[RP1]], i64 0, metadata [[META18]]), !tbaa [[TBAA11]], !noalias !18
// CHECK-NEXT:    store i32 43, ptr [[TMP3]], align 4, !tbaa [[TBAA13]], !noalias !18
// CHECK-NEXT:    ret void
//
void test_FOO_arg_value(struct FOO p) {
  *p.rp0 = 42;
  *p.rp1 = 43;
}
// NOTE: the struct is mapped 'byval', the scope will be introduced after inlining.

// define void @test_FOO_arg_value(%struct.FOO* byval(%struct.FOO) align 8 %p) #0 !noalias !18 {

// CHECK-LABEL: define dso_local void @test_FOO_pass(
// CHECK-SAME: ptr noalias sret([[STRUCT_FOO:%.*]]) align 8 [[AGG_RESULT:%.*]], ptr noundef byval([[STRUCT_FOO]]) align 8 [[P:%.*]]) #[[ATTR0]] !noalias !21 {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = call ptr @llvm.noalias.copy.guard.p0.p0(ptr [[P]], ptr null, metadata [[META24:![0-9]+]], metadata [[META21:![0-9]+]])
// CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 8 [[AGG_RESULT]], ptr align 8 [[TMP0]], i64 24, i1 false), !tbaa.struct [[TBAA_STRUCT25:![0-9]+]], !noalias !21
// CHECK-NEXT:    ret void
//
struct FOO test_FOO_pass(struct FOO p) {
  return p;
}

// define void @test_FOO_pass(%struct.FOO* noalias sret(%struct.FOO) align 8 %agg.result, %struct.FOO* byval(%struct.FOO) align 8 %p) #0 !noalias !21 {

struct FUM {
  struct FOO m;
};

// CHECK-LABEL: define dso_local void @test_FUM_local(
// CHECK-SAME: ptr noundef [[PA:%.*]], ptr noundef [[PB:%.*]], ptr noundef [[PC:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[PA_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[PB_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[PC_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[TMP:%.*]] = alloca [[STRUCT_FUM:%.*]], align 8
// CHECK-NEXT:    store ptr [[PA]], ptr [[PA_ADDR]], align 8, !tbaa [[TBAA2]], !noalias !26
// CHECK-NEXT:    store ptr [[PB]], ptr [[PB_ADDR]], align 8, !tbaa [[TBAA2]], !noalias !26
// CHECK-NEXT:    store ptr [[PC]], ptr [[PC_ADDR]], align 8, !tbaa [[TBAA2]], !noalias !26
// CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 24, ptr [[TMP]]) #[[ATTR6]], !noalias !26
// CHECK-NEXT:    [[TMP0:%.*]] = call ptr @llvm.noalias.decl.p0.p0.i64(ptr [[TMP]], i64 0, metadata [[META26:![0-9]+]]), !noalias !26
// CHECK-NEXT:    [[M:%.*]] = getelementptr inbounds [[STRUCT_FUM]], ptr [[TMP]], i32 0, i32 0
// CHECK-NEXT:    [[RP0:%.*]] = getelementptr inbounds [[STRUCT_FOO:%.*]], ptr [[M]], i32 0, i32 0
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[PA_ADDR]], align 8, !tbaa [[TBAA2]], !noalias !26
// CHECK-NEXT:    store ptr [[TMP1]], ptr [[RP0]], align 8, !tbaa [[TBAA9]], !noalias !26
// CHECK-NEXT:    [[RP1:%.*]] = getelementptr inbounds [[STRUCT_FOO]], ptr [[M]], i32 0, i32 1
// CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[PB_ADDR]], align 8, !tbaa [[TBAA2]], !noalias !26
// CHECK-NEXT:    store ptr [[TMP2]], ptr [[RP1]], align 8, !tbaa [[TBAA11]], !noalias !26
// CHECK-NEXT:    [[RP2:%.*]] = getelementptr inbounds [[STRUCT_FOO]], ptr [[M]], i32 0, i32 2
// CHECK-NEXT:    [[TMP3:%.*]] = load ptr, ptr [[PC_ADDR]], align 8, !tbaa [[TBAA2]], !noalias !26
// CHECK-NEXT:    store ptr [[TMP3]], ptr [[RP2]], align 8, !tbaa [[TBAA12]], !noalias !26
// CHECK-NEXT:    [[M1:%.*]] = getelementptr inbounds [[STRUCT_FUM]], ptr [[TMP]], i32 0, i32 0
// CHECK-NEXT:    [[RP02:%.*]] = getelementptr inbounds [[STRUCT_FOO]], ptr [[M1]], i32 0, i32 0
// CHECK-NEXT:    [[TMP4:%.*]] = load ptr, ptr [[RP02]], align 8, !tbaa [[TBAA29:![0-9]+]], !noalias !26
// CHECK-NEXT:    [[TMP5:%.*]] = call ptr @llvm.noalias.p0.p0.p0.i64(ptr [[TMP4]], ptr [[TMP0]], ptr [[RP02]], i64 0, metadata [[META26]]), !tbaa [[TBAA29]], !noalias !26
// CHECK-NEXT:    store i32 42, ptr [[TMP5]], align 4, !tbaa [[TBAA13]], !noalias !26
// CHECK-NEXT:    [[M3:%.*]] = getelementptr inbounds [[STRUCT_FUM]], ptr [[TMP]], i32 0, i32 0
// CHECK-NEXT:    [[RP14:%.*]] = getelementptr inbounds [[STRUCT_FOO]], ptr [[M3]], i32 0, i32 1
// CHECK-NEXT:    [[TMP6:%.*]] = load ptr, ptr [[RP14]], align 8, !tbaa [[TBAA31:![0-9]+]], !noalias !26
// CHECK-NEXT:    [[TMP7:%.*]] = call ptr @llvm.noalias.p0.p0.p0.i64(ptr [[TMP6]], ptr [[TMP0]], ptr [[RP14]], i64 0, metadata [[META26]]), !tbaa [[TBAA31]], !noalias !26
// CHECK-NEXT:    store i32 43, ptr [[TMP7]], align 4, !tbaa [[TBAA13]], !noalias !26
// CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 24, ptr [[TMP]]) #[[ATTR6]]
// CHECK-NEXT:    ret void
//
void test_FUM_local(int *pA, int *pB, int *pC) {
  struct FUM tmp = {{pA, pB, pC}};
  *tmp.m.rp0 = 42;
  *tmp.m.rp1 = 43;
}


// CHECK-LABEL: define dso_local void @test_FUM_arg_pointer(
// CHECK-SAME: ptr noundef [[P:%.*]]) #[[ATTR0]] !noalias !32 {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[P_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[P]], ptr [[P_ADDR]], align 8, !tbaa [[TBAA2]], !noalias !32
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P_ADDR]], align 8, !tbaa [[TBAA2]], !noalias !32
// CHECK-NEXT:    [[M:%.*]] = getelementptr inbounds [[STRUCT_FUM:%.*]], ptr [[TMP0]], i32 0, i32 0
// CHECK-NEXT:    [[RP0:%.*]] = getelementptr inbounds [[STRUCT_FOO:%.*]], ptr [[M]], i32 0, i32 0
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[RP0]], align 8, !tbaa [[TBAA29]], !noalias !32
// CHECK-NEXT:    [[TMP2:%.*]] = call ptr @llvm.noalias.p0.p0.p0.i64(ptr [[TMP1]], ptr null, ptr [[RP0]], i64 0, metadata [[META32:![0-9]+]]), !tbaa [[TBAA29]], !noalias !32
// CHECK-NEXT:    store i32 42, ptr [[TMP2]], align 4, !tbaa [[TBAA13]], !noalias !32
// CHECK-NEXT:    [[TMP3:%.*]] = load ptr, ptr [[P_ADDR]], align 8, !tbaa [[TBAA2]], !noalias !32
// CHECK-NEXT:    [[M1:%.*]] = getelementptr inbounds [[STRUCT_FUM]], ptr [[TMP3]], i32 0, i32 0
// CHECK-NEXT:    [[RP1:%.*]] = getelementptr inbounds [[STRUCT_FOO]], ptr [[M1]], i32 0, i32 1
// CHECK-NEXT:    [[TMP4:%.*]] = load ptr, ptr [[RP1]], align 8, !tbaa [[TBAA31]], !noalias !32
// CHECK-NEXT:    [[TMP5:%.*]] = call ptr @llvm.noalias.p0.p0.p0.i64(ptr [[TMP4]], ptr null, ptr [[RP1]], i64 0, metadata [[META32]]), !tbaa [[TBAA31]], !noalias !32
// CHECK-NEXT:    store i32 43, ptr [[TMP5]], align 4, !tbaa [[TBAA13]], !noalias !32
// CHECK-NEXT:    ret void
//
void test_FUM_arg_pointer(struct FUM *p) {
  *p->m.rp0 = 42;
  *p->m.rp1 = 43;
}
// define void @test_FUM_arg_pointer(%struct.FUM* %p) #0 !noalias !35 {

// CHECK-LABEL: define dso_local void @test_FUM_arg_value(
// CHECK-SAME: ptr noundef byval([[STRUCT_FUM:%.*]]) align 8 [[P:%.*]]) #[[ATTR0]] !noalias !35 {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[M:%.*]] = getelementptr inbounds [[STRUCT_FUM]], ptr [[P]], i32 0, i32 0
// CHECK-NEXT:    [[RP0:%.*]] = getelementptr inbounds [[STRUCT_FOO:%.*]], ptr [[M]], i32 0, i32 0
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[RP0]], align 8, !tbaa [[TBAA29]], !noalias !35
// CHECK-NEXT:    [[TMP1:%.*]] = call ptr @llvm.noalias.p0.p0.p0.i64(ptr [[TMP0]], ptr null, ptr [[RP0]], i64 0, metadata [[META35:![0-9]+]]), !tbaa [[TBAA29]], !noalias !35
// CHECK-NEXT:    store i32 42, ptr [[TMP1]], align 4, !tbaa [[TBAA13]], !noalias !35
// CHECK-NEXT:    [[M1:%.*]] = getelementptr inbounds [[STRUCT_FUM]], ptr [[P]], i32 0, i32 0
// CHECK-NEXT:    [[RP1:%.*]] = getelementptr inbounds [[STRUCT_FOO]], ptr [[M1]], i32 0, i32 1
// CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[RP1]], align 8, !tbaa [[TBAA31]], !noalias !35
// CHECK-NEXT:    [[TMP3:%.*]] = call ptr @llvm.noalias.p0.p0.p0.i64(ptr [[TMP2]], ptr null, ptr [[RP1]], i64 0, metadata [[META35]]), !tbaa [[TBAA31]], !noalias !35
// CHECK-NEXT:    store i32 43, ptr [[TMP3]], align 4, !tbaa [[TBAA13]], !noalias !35
// CHECK-NEXT:    ret void
//
void test_FUM_arg_value(struct FUM p) {
  *p.m.rp0 = 42;
  *p.m.rp1 = 43;
}

// define void @test_FUM_arg_value(%struct.FUM* byval(%struct.FUM) align 8 %p) #0 !noalias !38 {

// CHECK-LABEL: define dso_local void @test_FUM_pass(
// CHECK-SAME: ptr noalias sret([[STRUCT_FUM:%.*]]) align 8 [[AGG_RESULT:%.*]], ptr noundef byval([[STRUCT_FUM]]) align 8 [[P:%.*]]) #[[ATTR0]] !noalias !38 {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = call ptr @llvm.noalias.copy.guard.p0.p0(ptr [[P]], ptr null, metadata [[META24]], metadata [[META38:![0-9]+]])
// CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 8 [[AGG_RESULT]], ptr align 8 [[TMP0]], i64 24, i1 false), !tbaa.struct [[TBAA_STRUCT25]], !noalias !38
// CHECK-NEXT:    ret void
//
struct FUM test_FUM_pass(struct FUM p) {
  return p;
}

// indices for llvm.noalias.copy.guard
// CHECK: [[META24]] = !{i64 24, i64 0, i64 8, i64 3}
