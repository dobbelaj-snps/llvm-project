; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -S -jump-threading < %s | FileCheck %s

define void @test01(i32* %ptr1, i32* %ptr2) {
; CHECK-LABEL: @test01(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[V1_DECL:%.*]] = call i8* @llvm.noalias.decl.p0i8.p0p0i32.i32(i32** null, i32 0, metadata [[META0:![0-9]+]])
; CHECK-NEXT:    [[V1_PROV:%.*]] = call i32* @llvm.provenance.noalias.p0i32.p0i8.p0p0i32.p0p0i32.i32(i32* [[PTR1:%.*]], i8* [[V1_DECL]], i32** null, i32** null, i32 0, metadata [[META0]])
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[I:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[I_INC:%.*]], [[LATCH:%.*]] ]
; CHECK-NEXT:    [[C:%.*]] = icmp eq i32 [[I]], 100
; CHECK-NEXT:    br i1 [[C]], label [[EXIT:%.*]], label [[LATCH]]
; CHECK:       latch:
; CHECK-NEXT:    [[V2_DECL:%.*]] = call i8* @llvm.noalias.decl.p0i8.p0p0i32.i32(i32** null, i32 0, metadata [[META3:![0-9]+]])
; CHECK-NEXT:    [[V2_PROV:%.*]] = call i32* @llvm.provenance.noalias.p0i32.p0i8.p0p0i32.p0p0i32.i32(i32* [[PTR2:%.*]], i8* [[V2_DECL]], i32** null, i32** null, i32 0, metadata [[META3]])
; CHECK-NEXT:    store i32 0, i32* [[PTR1]], ptr_provenance i32* [[V1_PROV]], align 4, !noalias !0
; CHECK-NEXT:    store i32 1, i32* [[PTR2]], ptr_provenance i32* [[V2_PROV]], align 4, !noalias !3
; CHECK-NEXT:    [[I_INC]] = add i32 [[I]], 1
; CHECK-NEXT:    br label [[LOOP]]
; CHECK:       exit:
; CHECK-NEXT:    [[V2_DECL2:%.*]] = call i8* @llvm.noalias.decl.p0i8.p0p0i32.i32(i32** null, i32 0, metadata [[META3]])
; CHECK-NEXT:    [[V2_PROV3:%.*]] = call i32* @llvm.provenance.noalias.p0i32.p0i8.p0p0i32.p0p0i32.i32(i32* [[PTR2]], i8* [[V2_DECL2]], i32** null, i32** null, i32 0, metadata [[META3]])
; CHECK-NEXT:    store i32 0, i32* [[PTR1]], ptr_provenance i32* [[V1_PROV]], align 4, !noalias !0
; CHECK-NEXT:    store i32 1, i32* [[PTR2]], ptr_provenance i32* [[V2_PROV3]], align 4, !noalias !3
; CHECK-NEXT:    ret void
;
entry:
  %v1.decl = call i8* @llvm.noalias.decl.p0i8.p0p0i32.i32(i32** null, i32 0, metadata !0)
  %v1.prov = call i32* @llvm.provenance.noalias.p0i32.p0i8.p0p0i32.p0p0i32.i32(i32* %ptr1, i8* %v1.decl, i32** null, i32** null, i32 0, metadata !0)
  br label %loop

loop:
  %i = phi i32 [ 0, %entry ], [ %i.inc, %latch ]
  %c = icmp eq i32 %i, 100
  br i1 %c, label %if, label %latch

if:
  br label %latch

latch:
  %p = phi i1 [ true, %if ], [ false, %loop ]
  %v2.decl = call i8* @llvm.noalias.decl.p0i8.p0p0i32.i32(i32** null, i32 0, metadata !3)
  %v2.prov = call i32* @llvm.provenance.noalias.p0i32.p0i8.p0p0i32.p0p0i32.i32(i32* %ptr2, i8* %v2.decl, i32** null, i32** null, i32 0, metadata !3)
  store i32 0, i32* %ptr1, ptr_provenance i32* %v1.prov, !noalias !0
  store i32 1, i32* %ptr2, ptr_provenance i32* %v2.prov, !noalias !3
  ; store i32 2, i32* %ptr2, ptr_provenance i32* %v2.prov, !noalias !5
  %i.inc = add i32 %i, 1
  br i1 %p, label %exit, label %loop

exit:
  ret void
}

; Function Attrs: argmemonly nounwind
declare i8* @llvm.noalias.decl.p0i8.p0p0i32.i32(i32**, i32, metadata)

; Function Attrs: nounwind readnone speculatable
declare i32* @llvm.provenance.noalias.p0i32.p0i8.p0p0i32.p0p0i32.i32(i32*, i8*, i32**, i32**, i32, metadata)

!0 = !{!1}
!1 = distinct !{!1, !2, !"scope1"}
!2 = distinct !{!2, !"domain"}
!3 = !{!4}
!4 = distinct !{!4, !2, !"scope2"}
!5 = !{!1, !4}

; CHECK: !0 = !{!1}
; CHECK: !1 = distinct !{!1, !2, !"scope1"}
; CHECK: !2 = distinct !{!2, !"domain"}
; CHECK: !3 = !{!4}
; CHECK: !4 = distinct !{!4, !2, !"scope2"}
; CHECK-NOT: =

