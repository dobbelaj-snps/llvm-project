; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -S -passes=jump-threading < %s | FileCheck %s

define void @test01(ptr %ptr1, ptr %ptr2) {
; CHECK-LABEL: @test01(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[V1_DECL:%.*]] = call ptr @llvm.noalias.decl.p0.p0.i32(ptr null, i32 0, metadata [[META0:![0-9]+]])
; CHECK-NEXT:    [[V1_PROV:%.*]] = call ptr @llvm.provenance.noalias.p0.p0.p0.p0.i32(ptr [[PTR1:%.*]], ptr [[V1_DECL]], ptr null, ptr null, i32 0, metadata [[META0]])
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[I:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[I_INC:%.*]], [[LATCH:%.*]] ]
; CHECK-NEXT:    [[C:%.*]] = icmp eq i32 [[I]], 100
; CHECK-NEXT:    br i1 [[C]], label [[EXIT:%.*]], label [[LATCH]]
; CHECK:       latch:
; CHECK-NEXT:    [[V2_DECL:%.*]] = call ptr @llvm.noalias.decl.p0.p0.i32(ptr null, i32 0, metadata [[META3:![0-9]+]])
; CHECK-NEXT:    [[V2_PROV:%.*]] = call ptr @llvm.provenance.noalias.p0.p0.p0.p0.i32(ptr [[PTR2:%.*]], ptr [[V2_DECL]], ptr null, ptr null, i32 0, metadata [[META3]])
; CHECK-NEXT:    store i32 0, ptr [[PTR1]], ptr_provenance ptr [[V1_PROV]], align 4, !noalias !0
; CHECK-NEXT:    store i32 1, ptr [[PTR2]], ptr_provenance ptr [[V2_PROV]], align 4, !noalias !3
; CHECK-NEXT:    [[I_INC]] = add i32 [[I]], 1
; CHECK-NEXT:    br label [[LOOP]]
; CHECK:       exit:
; CHECK-NEXT:    [[V2_DECL2:%.*]] = call ptr @llvm.noalias.decl.p0.p0.i32(ptr null, i32 0, metadata [[META5:![0-9]+]])
; CHECK-NEXT:    [[V2_PROV3:%.*]] = call ptr @llvm.provenance.noalias.p0.p0.p0.p0.i32(ptr [[PTR2]], ptr [[V2_DECL2]], ptr null, ptr null, i32 0, metadata [[META5]])
; CHECK-NEXT:    store i32 0, ptr [[PTR1]], ptr_provenance ptr [[V1_PROV]], align 4, !noalias !0
; CHECK-NEXT:    store i32 1, ptr [[PTR2]], ptr_provenance ptr [[V2_PROV3]], align 4, !noalias !5
; CHECK-NEXT:    ret void
;
entry:
  %v1.decl = call ptr @llvm.noalias.decl.p0.p0.i32(ptr null, i32 0, metadata !0)
  %v1.prov = call ptr @llvm.provenance.noalias.p0.p0.p0.p0.i32(ptr %ptr1, ptr %v1.decl, ptr null, ptr null, i32 0, metadata !0)
  br label %loop

loop:
  %i = phi i32 [ 0, %entry ], [ %i.inc, %latch ]
  %c = icmp eq i32 %i, 100
  br i1 %c, label %if, label %latch

if:
  br label %latch

latch:
  %p = phi i1 [ true, %if ], [ false, %loop ]
  %v2.decl = call ptr @llvm.noalias.decl.p0.p0.i32(ptr null, i32 0, metadata !3)
  %v2.prov = call ptr @llvm.provenance.noalias.p0.p0.p0.p0.i32(ptr %ptr2, ptr %v2.decl, ptr null, ptr null, i32 0, metadata !3)
  store i32 0, ptr %ptr1, ptr_provenance ptr %v1.prov, !noalias !0
  store i32 1, ptr %ptr2, ptr_provenance ptr %v2.prov, !noalias !3
  ; store i32 2, ptr %ptr2, ptr_provenance ptr %v2.prov, !noalias !5
  %i.inc = add i32 %i, 1
  br i1 %p, label %exit, label %loop

exit:
  ret void
}

; Function Attrs: argmemonly nounwind
declare ptr @llvm.noalias.decl.p0.p0.i32(ptr, i32, metadata)

; Function Attrs: nounwind readnone speculatable
declare ptr @llvm.provenance.noalias.p0.p0.p0.p0.i32(ptr, ptr, ptr, ptr, i32, metadata)

!0 = !{!1}
!1 = distinct !{!1, !2, !"scope1"}
!2 = distinct !{!2, !"domain"}
!3 = !{!4}
!4 = distinct !{!4, !2, !"scope2"}
!5 = !{!1, !4}

; CHECK: !0 = !{!1}
; CHECK: !1 = distinct !{!1, !2, !"scope1"}
; CHECK: !2 = distinct !{!2, !"domain"}
; CHECK: !3 = !{!4}
; CHECK: !4 = distinct !{!4, !2, !"scope2"}
; CHECK: !5 = !{!6}
; CHECK: !6 = distinct !{!6, !2, !"scope2:thread"}
; CHECK-NOT: =

