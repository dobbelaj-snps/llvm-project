; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -passes='default<O2>' -S < %s | FileCheck %s

define void @copy(ptr noalias %to, ptr noalias %from) {
; CHECK-LABEL: @copy(
; CHECK-NEXT:    [[X:%.*]] = load i32, ptr [[FROM:%.*]], align 4
; CHECK-NEXT:    store i32 [[X]], ptr [[TO:%.*]], align 4
; CHECK-NEXT:    ret void
;
  %x = load i32, ptr %from
  store i32 %x, ptr %to
  ret void
}

; Consider that %addr1 = %addr2 + 1, in which case %addr2i and %addr1i are
; noalias within one iteration, but may alias across iterations.
define void @pr39282(ptr %addr1, ptr %addr2) {
; CHECK-LABEL: @pr39282(
; CHECK-NEXT:  start:
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.noalias.decl.p0.p0.i64(ptr null, i64 0, metadata [[META0:![0-9]+]])
; CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.provenance.noalias.p0.p0.p0.p0.i64(ptr [[ADDR2:%.*]], ptr [[TMP0]], ptr null, ptr undef, i64 0, metadata [[META0]]), !noalias !3
; CHECK-NEXT:    [[TMP2:%.*]] = tail call ptr @llvm.noalias.decl.p0.p0.i64(ptr null, i64 0, metadata [[META5:![0-9]+]])
; CHECK-NEXT:    [[TMP3:%.*]] = tail call ptr @llvm.provenance.noalias.p0.p0.p0.p0.i64(ptr [[ADDR1:%.*]], ptr [[TMP2]], ptr null, ptr undef, i64 0, metadata [[META5]]), !noalias !3
; CHECK-NEXT:    [[X_I:%.*]] = load i32, ptr [[ADDR1]], ptr_provenance ptr [[TMP3]], align 4, !noalias !3
; CHECK-NEXT:    store i32 [[X_I]], ptr [[ADDR2]], ptr_provenance ptr [[TMP1]], align 4, !noalias !3
; CHECK-NEXT:    [[ADDR1I_1:%.*]] = getelementptr inbounds i32, ptr [[ADDR1]], i64 1
; CHECK-NEXT:    [[ADDR2I_1:%.*]] = getelementptr inbounds i32, ptr [[ADDR2]], i64 1
; CHECK-NEXT:    [[TMP4:%.*]] = tail call ptr @llvm.noalias.decl.p0.p0.i64(ptr null, i64 0, metadata [[META6:![0-9]+]])
; CHECK-NEXT:    [[TMP5:%.*]] = tail call ptr @llvm.provenance.noalias.p0.p0.p0.p0.i64(ptr nonnull [[ADDR2I_1]], ptr [[TMP4]], ptr null, ptr undef, i64 0, metadata [[META6]]), !noalias !8
; CHECK-NEXT:    [[TMP6:%.*]] = tail call ptr @llvm.noalias.decl.p0.p0.i64(ptr null, i64 0, metadata [[META10:![0-9]+]])
; CHECK-NEXT:    [[TMP7:%.*]] = tail call ptr @llvm.provenance.noalias.p0.p0.p0.p0.i64(ptr nonnull [[ADDR1I_1]], ptr [[TMP6]], ptr null, ptr undef, i64 0, metadata [[META10]]), !noalias !8
; CHECK-NEXT:    [[X_I_1:%.*]] = load i32, ptr [[ADDR1I_1]], ptr_provenance ptr [[TMP7]], align 4, !noalias !8
; CHECK-NEXT:    store i32 [[X_I_1]], ptr [[ADDR2I_1]], ptr_provenance ptr [[TMP5]], align 4, !noalias !8
; CHECK-NEXT:    [[TMP8:%.*]] = tail call ptr @llvm.noalias.decl.p0.p0.i64(ptr null, i64 0, metadata [[META11:![0-9]+]])
; CHECK-NEXT:    [[TMP9:%.*]] = tail call ptr @llvm.provenance.noalias.p0.p0.p0.p0.i64(ptr nonnull [[ADDR2]], ptr [[TMP8]], ptr null, ptr undef, i64 0, metadata [[META11]]), !noalias !13
; CHECK-NEXT:    [[TMP10:%.*]] = tail call ptr @llvm.noalias.decl.p0.p0.i64(ptr null, i64 0, metadata [[META15:![0-9]+]])
; CHECK-NEXT:    [[TMP11:%.*]] = tail call ptr @llvm.provenance.noalias.p0.p0.p0.p0.i64(ptr nonnull [[ADDR1]], ptr [[TMP10]], ptr null, ptr undef, i64 0, metadata [[META15]]), !noalias !13
; CHECK-NEXT:    [[X_I_2:%.*]] = load i32, ptr [[ADDR1]], ptr_provenance ptr [[TMP11]], align 4, !noalias !13
; CHECK-NEXT:    store i32 [[X_I_2]], ptr [[ADDR2]], ptr_provenance ptr [[TMP9]], align 4, !noalias !13
; CHECK-NEXT:    [[TMP12:%.*]] = tail call ptr @llvm.noalias.decl.p0.p0.i64(ptr null, i64 0, metadata [[META16:![0-9]+]])
; CHECK-NEXT:    [[TMP13:%.*]] = tail call ptr @llvm.provenance.noalias.p0.p0.p0.p0.i64(ptr nonnull [[ADDR2I_1]], ptr [[TMP12]], ptr null, ptr undef, i64 0, metadata [[META16]]), !noalias !18
; CHECK-NEXT:    [[TMP14:%.*]] = tail call ptr @llvm.noalias.decl.p0.p0.i64(ptr null, i64 0, metadata [[META20:![0-9]+]])
; CHECK-NEXT:    [[TMP15:%.*]] = tail call ptr @llvm.provenance.noalias.p0.p0.p0.p0.i64(ptr nonnull [[ADDR1I_1]], ptr [[TMP14]], ptr null, ptr undef, i64 0, metadata [[META20]]), !noalias !18
; CHECK-NEXT:    [[X_I_3:%.*]] = load i32, ptr [[ADDR1I_1]], ptr_provenance ptr [[TMP15]], align 4, !noalias !18
; CHECK-NEXT:    store i32 [[X_I_3]], ptr [[ADDR2I_1]], ptr_provenance ptr [[TMP13]], align 4, !noalias !18
; CHECK-NEXT:    ret void
;
start:
  br label %body

body:
  %i = phi i32 [ 0, %start ], [ %i.next, %body ]
  %j = and i32 %i, 1
  %addr1i = getelementptr inbounds i32, ptr %addr1, i32 %j
  %addr2i = getelementptr inbounds i32, ptr %addr2, i32 %j
  call void @copy(ptr %addr2i, ptr %addr1i)
  %i.next = add i32 %i, 1
  %cmp = icmp slt i32 %i.next, 4
  br i1 %cmp, label %body, label %end

end:
  ret void
}
