; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; ModuleID = 'zzz_test.ll'
; RUN: opt < %s -S -passes=loop-unroll -unroll-force-peel-count=1 | FileCheck %s
; RUN: opt < %s -S -passes='loop-unroll<peeling;no-runtime>' -unroll-force-peel-count=1 | FileCheck %s
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

@b = external local_unnamed_addr global i32, align 4

; Function Attrs: nofree nosync nounwind uwtable
define i32 @f() local_unnamed_addr #0 {
; CHECK-LABEL: @f(
; CHECK-NEXT:  g.preheader:
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr @b, align 4, !tbaa [[TBAA0:![0-9]+]]
; CHECK-NEXT:    [[CMP_NOT4:%.*]] = icmp slt i32 undef, [[TMP0]]
; CHECK-NEXT:    br label [[IF_THEN_PREHEADER:%.*]]
; CHECK:       if.then.preheader:
; CHECK-NEXT:    br label [[IF_THEN_PEEL_BEGIN:%.*]]
; CHECK:       if.then.peel.begin:
; CHECK-NEXT:    br label [[IF_THEN_PEEL:%.*]]
; CHECK:       if.then.peel:
; CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.noalias.decl.p0.p0.i64(ptr null, i64 0, metadata [[META4:![0-9]+]])
; CHECK-NEXT:    [[CONV_PEEL:%.*]] = sext i32 [[TMP0]] to i64
; CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[CONV_PEEL]] to ptr
; CHECK-NEXT:    [[CMP_NOT_PEEL:%.*]] = icmp slt i32 undef, 1
; CHECK-NEXT:    br i1 [[CMP_NOT_PEEL]], label [[G_IF_END_CRIT_EDGE:%.*]], label [[IF_THEN_PEEL_NEXT:%.*]]
; CHECK:       if.then.peel.next:
; CHECK-NEXT:    br label [[IF_THEN_PEEL_NEXT1:%.*]]
; CHECK:       if.then.peel.next1:
; CHECK-NEXT:    br label [[IF_THEN_PREHEADER_PEEL_NEWPH:%.*]]
; CHECK:       if.then.preheader.peel.newph:
; CHECK-NEXT:    br label [[IF_THEN:%.*]]
; CHECK:       if.then:
; CHECK-NEXT:    [[TMP3:%.*]] = tail call ptr @llvm.noalias.decl.p0.p0.i64(ptr null, i64 0, metadata [[META7:![0-9]+]])
; CHECK-NEXT:    br i1 false, label [[G_IF_END_CRIT_EDGE_LOOPEXIT:%.*]], label [[IF_THEN]], !llvm.loop [[LOOP9:![0-9]+]]
; CHECK:       g.if.end_crit_edge.loopexit:
; CHECK-NEXT:    [[DOTLCSSA5_PH:%.*]] = phi ptr [ [[TMP3]], [[IF_THEN]] ]
; CHECK-NEXT:    [[DOTLCSSA_PH:%.*]] = phi ptr [ inttoptr (i64 1 to ptr), [[IF_THEN]] ]
; CHECK-NEXT:    br label [[G_IF_END_CRIT_EDGE]]
; CHECK:       g.if.end_crit_edge:
; CHECK-NEXT:    [[DOTLCSSA5:%.*]] = phi ptr [ [[TMP1]], [[IF_THEN_PEEL]] ], [ [[DOTLCSSA5_PH]], [[G_IF_END_CRIT_EDGE_LOOPEXIT]] ]
; CHECK-NEXT:    [[DOTLCSSA:%.*]] = phi ptr [ [[TMP2]], [[IF_THEN_PEEL]] ], [ [[DOTLCSSA_PH]], [[G_IF_END_CRIT_EDGE_LOOPEXIT]] ]
; CHECK-NEXT:    [[TMP4:%.*]] = tail call ptr @llvm.noalias.decl.p0.p0.i64(ptr null, i64 0, metadata [[META12:![0-9]+]])
; CHECK-NEXT:    [[TMP5:%.*]] = tail call ptr @llvm.provenance.noalias.p0.p0.p0.p0.i64(ptr [[DOTLCSSA]], ptr [[TMP4]], ptr null, ptr undef, i64 0, metadata [[META12]]), !noalias !12
; CHECK-NEXT:    [[DOTGUARD_GUARD:%.*]] = tail call ptr @llvm.experimental.ptr.provenance.p0.p0(ptr [[DOTLCSSA]], ptr [[TMP5]])
; CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[DOTGUARD_GUARD]] to i64
; CHECK-NEXT:    [[TMP7:%.*]] = trunc i64 [[TMP6]] to i32
; CHECK-NEXT:    store i32 1, ptr @b, align 4, !tbaa [[TBAA0]]
; CHECK-NEXT:    ret i32 undef
;
g.preheader:
  %0 = load i32, ptr @b, align 4, !tbaa !0
  %cmp.not4 = icmp slt i32 undef, %0
  br label %if.then.preheader

if.then.preheader:                                ; preds = %g.preheader
  br label %if.then

if.then:                                          ; preds = %if.then, %if.then.preheader
  %1 = phi i32 [ 1, %if.then ], [ %0, %if.then.preheader ]
  %2 = tail call ptr @llvm.noalias.decl.p0.p0.i64(ptr null, i64 0, metadata !4)
  %conv = sext i32 %1 to i64
  %3 = inttoptr i64 %conv to ptr
  %cmp.not = icmp slt i32 undef, 1
  br i1 %cmp.not, label %g.if.end_crit_edge, label %if.then

g.if.end_crit_edge:                               ; preds = %if.then
  %.lcssa5 = phi ptr [ %2, %if.then ]
  %.lcssa = phi ptr [ %3, %if.then ]
  %4 = tail call ptr @llvm.provenance.noalias.p0.p0.p0.p0.i64(ptr %.lcssa, ptr %.lcssa5, ptr null, ptr undef, i64 0, metadata !4), !noalias !4
  %.guard.guard = tail call ptr @llvm.experimental.ptr.provenance.p0.p0(ptr %.lcssa, ptr %4)
  %5 = ptrtoint ptr %.guard.guard to i64
  %6 = trunc i64 %5 to i32
  store i32 1, ptr @b, align 4, !tbaa !0
  ret i32 undef
}

; Function Attrs: inaccessiblememonly nofree nosync nounwind willreturn
declare ptr @llvm.noalias.decl.p0.p0.i64(ptr, i64, metadata) #1

; Function Attrs: nofree nosync nounwind readnone speculatable willreturn
declare ptr @llvm.provenance.noalias.p0.p0.p0.p0.i64(ptr, ptr, ptr, ptr, i64, metadata) #2

; Function Attrs: nofree nosync nounwind readnone speculatable willreturn
declare ptr @llvm.experimental.ptr.provenance.p0.p0(ptr, ptr) #2

attributes #0 = { nofree nosync nounwind uwtable "frame-pointer"="none" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #1 = { inaccessiblememonly nofree nosync nounwind willreturn }
attributes #2 = { nofree nosync nounwind readnone speculatable willreturn }

!0 = !{!1, !1, i64 0}
!1 = !{!"int", !2, i64 0}
!2 = !{!"omnipotent char", !3, i64 0}
!3 = !{!"Simple C/C++ TBAA"}
!4 = !{!5}
!5 = distinct !{!5, !6, !"f: h"}
!6 = distinct !{!6, !"f"}

; CHECK: !0 = !{!1, !1, i64 0}
; CHECK: !1 = !{!"int", !2, i64 0}
; CHECK: !2 = !{!"omnipotent char", !3, i64 0}
; CHECK: !3 = !{!"Simple C/C++ TBAA"}
; CHECK: !4 = !{!5}
; CHECK: !5 = distinct !{!5, !6, !"f: h:Peel0"}
; CHECK: !6 = distinct !{!6, !"f"}
; CHECK: !7 = !{!8}
; CHECK: !8 = distinct !{!8, !6, !"f: h:NotPeeled"}
; CHECK: !9 = distinct !{!9, !10, !11}
; CHECK: !10 = !{!"llvm.loop.peeled.count", i32 1}
; CHECK: !11 = !{!"llvm.loop.unroll.disable"}
; CHECK: !12 = !{!13}
; CHECK: !13 = distinct !{!13, !6, !"f: h"}
